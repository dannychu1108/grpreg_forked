}
family <- match.arg(family)
penalty <- match.arg(penalty)
if (gamma <= 1 & penalty %in% c("grMCP", "cMCP")) stop("gamma must be greater than 1 for the MC penalty", call.=FALSE)
if (gamma <= 2 & penalty=="grSCAD") stop("gamma must be greater than 2 for the SCAD penalty", call.=FALSE)
if (nlambda < 2) stop("nlambda must be at least 2", call.=FALSE)
if (alpha > 1 | alpha <= 0) stop("alpha must be in (0, 1]", call.=FALSE)
# Check for grouped_hat object
if (class(X) = "grouped_hat"){
group <- X$groups
X <- X$x
}
# Construct XG, yy
bilevel <- strtrim(penalty, 2) != "gr"
yy <- newY(y, family)
XG <- newXG(X, group, group.multiplier, attr(yy, 'm'), bilevel)
if (nrow(XG$X) != length(yy)) stop("X and y do not have the same number of observations", call.=FALSE)
# Setup lambda
if (missing(lambda)) {
lambda <- setupLambda(XG$X, yy, XG$g, family, penalty, alpha, lambda.min, log.lambda, nlambda, XG$m)
lam.max <- lambda[1]
user.lambda <- FALSE
} else {
lam.max <- -1
nlambda <- length(lambda)
user.lambda <- TRUE
}
# Fit
n <- length(yy)
p <- ncol(XG$X)
K <- as.integer(table(XG$g))
K0 <- as.integer(if (min(XG$g)==0) K[1] else 0)
K1 <- as.integer(if (min(XG$g)==0) cumsum(K) else c(0, cumsum(K)))
if (K0) {
lambda[1] <- lambda[1] + 1e-5
user.lambda <- TRUE
}
if (family=="gaussian") {
if (bilevel) fit <- .Call("lcdfit_gaussian", XG$X, yy, penalty, K1, K0, lambda, alpha, eps, 0, gamma, tau, as.integer(max.iter), XG$m, as.integer(dfmax), as.integer(gmax), as.integer(user.lambda))
else fit <- .Call("gdfit_gaussian", XG$X, yy, penalty, K1, K0, lambda, lam.max, alpha, eps, as.integer(max.iter), gamma, XG$m, as.integer(dfmax), as.integer(gmax), as.integer(user.lambda))
b <- rbind(mean(y), matrix(fit[[1]], nrow=p))
iter <- fit[[2]]
df <- fit[[3]] + 1 # Intercept
loss <- fit[[4]]
} else {
if (bilevel) fit <- .Call("lcdfit_glm", XG$X, yy, family, penalty, K1, K0, lambda, alpha, eps, 0, gamma, tau, as.integer(max.iter), XG$m, as.integer(dfmax), as.integer(gmax), as.integer(warn), as.integer(user.lambda))
else fit <- .Call("gdfit_glm", XG$X, yy, family, penalty, K1, K0, lambda, alpha, eps, as.integer(max.iter), gamma, XG$m, as.integer(dfmax), as.integer(gmax), as.integer(warn), as.integer(user.lambda))
b <- rbind(fit[[1]], matrix(fit[[2]], nrow=p))
iter <- fit[[3]]
df <- fit[[4]]
loss <- fit[[5]]
}
# Eliminate saturated lambda values, if any
ind <- !is.na(iter)
b <- b[, ind, drop=FALSE]
iter <- iter[ind]
lambda <- lambda[ind]
df <- df[ind]
loss <- loss[ind]
if (iter[1] == max.iter) stop("Algorithm failed to converge for any values of lambda.  This indicates a combination of (a) an ill-conditioned feature matrix X and (b) insufficient penalization.  You must fix one or the other for your model to be identifiable.", call.=FALSE)
if (warn & any(iter==max.iter)) warning("Algorithm failed to converge for all values of lambda", call.=FALSE)
# Unstandardize
if (strtrim(penalty,2)=="gr") b <- unorthogonalize(b, XG$X, XG$g)
if (XG$reorder) b[-1,] <- b[1+XG$ord.inv,]
beta <- unstandardize(b, XG)
# Names
varnames <- c("(Intercept)", XG$names)
ncolY <- attr(yy, 'm')
if (ncolY > 1) {
beta[2:ncolY,] <- sweep(beta[2:ncolY, , drop=FALSE], 2, beta[1,], FUN="+")
beta <- array(beta, dim=c(ncolY, nrow(beta)/ncolY, ncol(beta)))
group <- group[-(1:(ncolY-1))]
dimnames(beta) <- list(colnames(yy), varnames, round(lambda, digits=4))
} else {
dimnames(beta) <- list(varnames, round(lambda, digits=4))
}
val <- structure(list(beta = beta,
family = family,
group = factor(group),
lambda = lambda,
alpha = alpha,
loss = loss,
n = n,
penalty = penalty,
df = df,
iter = iter,
group.multiplier = XG$m),
class = "grpreg")
if (returnX) {
val$XG = XG
val$y = yy
} else if (family=="poisson") {
val$y <- y
}
val
}
grpreg <- function(X, y, group=1:ncol(X), penalty=c("grLasso", "grMCP", "grSCAD", "gel", "cMCP"),
family=c("gaussian","binomial", "poisson"), nlambda=100, lambda,
lambda.min={if (nrow(X) > ncol(X)) 1e-4 else .05}, log.lambda = TRUE,
alpha=1, eps=1e-4, max.iter=10000, dfmax=p, gmax=length(unique(group)),
gamma=ifelse(penalty=="grSCAD", 4, 3), tau=1/3, group.multiplier,
warn=TRUE, returnX=FALSE, ...) {
# Deprecation support / error checking
if (!missing(penalty)) {
if (penalty[1]=="gBridge") stop("gBridge has been divorced from the grpreg function; use the gBridge() function instead", call.=FALSE)
if (penalty[1]=="gMCP") {
writeLines(strwrap("penalty='gMCP' is deprecated and may not be supported in future versions.  Use penalty='cMCP' instead."))
penalty <- "cMCP"
}
if (penalty[1]=="gLasso") {
writeLines(strwrap("You have specified penalty='gLasso'; grpreg is assuming you mean group lasso (penalty='grLasso')"))
penalty <- "grLasso"
}
}
family <- match.arg(family)
penalty <- match.arg(penalty)
if (gamma <= 1 & penalty %in% c("grMCP", "cMCP")) stop("gamma must be greater than 1 for the MC penalty", call.=FALSE)
if (gamma <= 2 & penalty=="grSCAD") stop("gamma must be greater than 2 for the SCAD penalty", call.=FALSE)
if (nlambda < 2) stop("nlambda must be at least 2", call.=FALSE)
if (alpha > 1 | alpha <= 0) stop("alpha must be in (0, 1]", call.=FALSE)
# Check for grouped_hat object
if (class(X) == "grouped_hat"){
group <- X$groups
X <- X$x
}
# Construct XG, yy
bilevel <- strtrim(penalty, 2) != "gr"
yy <- newY(y, family)
XG <- newXG(X, group, group.multiplier, attr(yy, 'm'), bilevel)
if (nrow(XG$X) != length(yy)) stop("X and y do not have the same number of observations", call.=FALSE)
# Setup lambda
if (missing(lambda)) {
lambda <- setupLambda(XG$X, yy, XG$g, family, penalty, alpha, lambda.min, log.lambda, nlambda, XG$m)
lam.max <- lambda[1]
user.lambda <- FALSE
} else {
lam.max <- -1
nlambda <- length(lambda)
user.lambda <- TRUE
}
# Fit
n <- length(yy)
p <- ncol(XG$X)
K <- as.integer(table(XG$g))
K0 <- as.integer(if (min(XG$g)==0) K[1] else 0)
K1 <- as.integer(if (min(XG$g)==0) cumsum(K) else c(0, cumsum(K)))
if (K0) {
lambda[1] <- lambda[1] + 1e-5
user.lambda <- TRUE
}
if (family=="gaussian") {
if (bilevel) fit <- .Call("lcdfit_gaussian", XG$X, yy, penalty, K1, K0, lambda, alpha, eps, 0, gamma, tau, as.integer(max.iter), XG$m, as.integer(dfmax), as.integer(gmax), as.integer(user.lambda))
else fit <- .Call("gdfit_gaussian", XG$X, yy, penalty, K1, K0, lambda, lam.max, alpha, eps, as.integer(max.iter), gamma, XG$m, as.integer(dfmax), as.integer(gmax), as.integer(user.lambda))
b <- rbind(mean(y), matrix(fit[[1]], nrow=p))
iter <- fit[[2]]
df <- fit[[3]] + 1 # Intercept
loss <- fit[[4]]
} else {
if (bilevel) fit <- .Call("lcdfit_glm", XG$X, yy, family, penalty, K1, K0, lambda, alpha, eps, 0, gamma, tau, as.integer(max.iter), XG$m, as.integer(dfmax), as.integer(gmax), as.integer(warn), as.integer(user.lambda))
else fit <- .Call("gdfit_glm", XG$X, yy, family, penalty, K1, K0, lambda, alpha, eps, as.integer(max.iter), gamma, XG$m, as.integer(dfmax), as.integer(gmax), as.integer(warn), as.integer(user.lambda))
b <- rbind(fit[[1]], matrix(fit[[2]], nrow=p))
iter <- fit[[3]]
df <- fit[[4]]
loss <- fit[[5]]
}
# Eliminate saturated lambda values, if any
ind <- !is.na(iter)
b <- b[, ind, drop=FALSE]
iter <- iter[ind]
lambda <- lambda[ind]
df <- df[ind]
loss <- loss[ind]
if (iter[1] == max.iter) stop("Algorithm failed to converge for any values of lambda.  This indicates a combination of (a) an ill-conditioned feature matrix X and (b) insufficient penalization.  You must fix one or the other for your model to be identifiable.", call.=FALSE)
if (warn & any(iter==max.iter)) warning("Algorithm failed to converge for all values of lambda", call.=FALSE)
# Unstandardize
if (strtrim(penalty,2)=="gr") b <- unorthogonalize(b, XG$X, XG$g)
if (XG$reorder) b[-1,] <- b[1+XG$ord.inv,]
beta <- unstandardize(b, XG)
# Names
varnames <- c("(Intercept)", XG$names)
ncolY <- attr(yy, 'm')
if (ncolY > 1) {
beta[2:ncolY,] <- sweep(beta[2:ncolY, , drop=FALSE], 2, beta[1,], FUN="+")
beta <- array(beta, dim=c(ncolY, nrow(beta)/ncolY, ncol(beta)))
group <- group[-(1:(ncolY-1))]
dimnames(beta) <- list(colnames(yy), varnames, round(lambda, digits=4))
} else {
dimnames(beta) <- list(varnames, round(lambda, digits=4))
}
val <- structure(list(beta = beta,
family = family,
group = factor(group),
lambda = lambda,
alpha = alpha,
loss = loss,
n = n,
penalty = penalty,
df = df,
iter = iter,
group.multiplier = XG$m),
class = "grpreg")
if (returnX) {
val$XG = XG
val$y = yy
} else if (family=="poisson") {
val$y <- y
}
val
}
library(grpreg)
y <- rnorm(n)
grpreg(hat, y, penalty = "grLasso", family = "gaussian")
install.packages("tinytest")
install.packages("roxygen2")
?bs
?splines::bs
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
p <- 10
bslist <- list(rep(NA, p))
bslist <- vector(mode = "list", length = p)
bslist[1] <- 16
}
}
}
}
grpmat <- function(x, df = 4, degree = 3, type = "bs"){
x <- matrix(runif(20), 5, 4)
x <- matrix(runif(20), 5, 4)
}
x <- matrix(runif(20), 5, 4)
x
bs <- grpmat(x)
grpmat(x)
x <- matrix(runif(20), 5, 4)
bs <- grpmat(x)
devtools::load_all()
devtools::load_all()
x <- matrix(runif(20), 5, 4)
bs <- grpmat(x)
p <- 10
bslist <- vector(mode = "list", length = p)
bslist[1] <- x
bslist[1]
bs(x)
splines::bs(x)
bs <- splines::bs(x)
View(bs)
attr(bs(x), "knots")
attr(bs, "knots")
bs <- splines::bs(x, df = 4)
bs
bs <- splines::bs(x, df = 5)
bs
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
?bs
bs <- splines::bs(x, df = 6)
bs
knots <- rep(list(rep(NA, df-3)), p)
knots <- rep(list(rep(NA, (df-3))), p)
df = 4
knots <- rep(list(rep(NA, (df-3))), p)
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
df <- 5
knots <- rep(list(rep(NA, (df-3))), p)
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
knots[2]
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
knots[2] <- 1:2
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
length(knots[1]) <-
#' \code{c(nrow(x), df*ncol(x))} and a vector of length
#' \code{df*ncol(x)}
#'
#' @examples
#'
#' X <- grpmat(attitude[-1], df = 3)
#' fit <- grpreg(X, attitude$rating, penalty="grLasso")
#' plot(fit)
#'
#'
length(knots[1])
length(knots[1])
length(knots[[1]])
bs
bs <- splines::bs(x, df = 6, degree = 2)
bs
bs1 <- bs[,1]
bs1
bs <- splines::bs(x, df = 4)
bs
bs1 <- cbind(bs[,1], bs[,2], bs[,3], bs[,4])
bs1
attributes(bs)
attributes(bs1)
attributes(bs1, "degree") <- 3
attr(bs1, "degree") <- 3
attributes(bs1)
attr(bs1, "class") <- c("bs", "basis", "matrix")
bs1
bs
?predict.bs
devtools::load_all()
}
devtools::load_all()
}
}
}
grpmat <- function(x, df = 4, degree = 3, type = "bs"){
grpmat <- function(x, df = 4, degree = 3, type = "bs"){
#if(type == "ns"){
#  degree <- 3 #provide warning
#}
n <- nrow(x)
p <- ncol(x)
finalx <- matrix(NA, n, (p*df))
knots <- rep(list(rep(NA, (df-degree))), p)
boundary <- rep(list(rep(NA, 2), p)
if(type == "bs"){
for(i in 0:(p-1)){
bs <- splines::bs(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- bs
boundary[[i+1]] <- attr(bs, "Boundary.knots")
knots[[i+1]] <- attr(bs, "knots")
}
}
else if(type == "ns"){
for(i in 0:(p-1)){
ns <- splines::ns(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- ns
boundary[[i+1]] <- attr(ns, "Boundary.knots")
knots[[i+1]] <- attr(ns, "knots")
}
}
else{
stop(paste(type, "is not a valid type"))
}
if(length(colnames(x)) == p){
groups <- rep(colnames(x), each = df)
colnames(finalx) <- paste0(groups, 1:df)
}
else{
groups <- rep(paste0("V", 1:p), each = df)
colnames(finalx) <- paste(groups, 1:df, sep = "_")
}
return(structure(list(x = finalx,
groups = groups,
knots = knots,
boundary = boundary,
degree = degree), class='grouped_mat'))
}
grpmat <- function(x, df = 4, degree = 3, type = "bs"){
#if(type == "ns"){
#  degree <- 3 #provide warning
#}
n <- nrow(x)
p <- ncol(x)
finalx <- matrix(NA, n, (p*df))
knots <- rep(list(rep(NA, (df-degree))), p)
boundary <- rep(list(rep(NA, 2), p)
if(type == "bs"){
for(i in 0:(p-1)){
bs <- splines::bs(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- bs
boundary[[i+1]] <- attr(bs, "Boundary.knots")
knots[[i+1]] <- attr(bs, "knots")
}
}
else if(type == "ns"){
for(i in 0:(p-1)){
ns <- splines::ns(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- ns
boundary[[i+1]] <- attr(ns, "Boundary.knots")
knots[[i+1]] <- attr(ns, "knots")
}
}
else{
stop(paste(type, "is not a valid type"))
}
if(length(colnames(x)) == p){
groups <- rep(colnames(x), each = df)
colnames(finalx) <- paste0(groups, 1:df)
}
else{
groups <- rep(paste0("V", 1:p), each = df)
colnames(finalx) <- paste(groups, 1:df, sep = "_")
}
return(structure(list(x = finalx,
groups = groups,
knots = knots,
boundary = boundary,
degree = degree), class='grouped_mat'))
}
grpmat <- function(x, df = 4, degree = 3, type = "bs"){
#if(type == "ns"){
#  degree <- 3 #provide warning
#}
n <- nrow(x)
p <- ncol(x)
finalx <- matrix(NA, n, (p*df))
knots <- rep(list(rep(NA, (df-degree))), p)
boundary <- rep(list(rep(NA, 2)), p)
if(type == "bs"){
for(i in 0:(p-1)){
bs <- splines::bs(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- bs
boundary[[i+1]] <- attr(bs, "Boundary.knots")
knots[[i+1]] <- attr(bs, "knots")
}
}
else if(type == "ns"){
for(i in 0:(p-1)){
ns <- splines::ns(x[,i], df = df, degree = degree)
finalx[,(df*i+1):(df*i+df)] <- ns
boundary[[i+1]] <- attr(ns, "Boundary.knots")
knots[[i+1]] <- attr(ns, "knots")
}
}
else{
stop(paste(type, "is not a valid type"))
}
if(length(colnames(x)) == p){
groups <- rep(colnames(x), each = df)
colnames(finalx) <- paste0(groups, 1:df)
}
else{
groups <- rep(paste0("V", 1:p), each = df)
colnames(finalx) <- paste(groups, 1:df, sep = "_")
}
return(structure(list(x = finalx,
groups = groups,
knots = knots,
boundary = boundary,
degree = degree), class='grouped_mat'))
}
devtools::load_all()
attitude[-1]
attnoy <- attitude[-1]
grpmat(attnoy[1,], df = 4)
grpmat(attnoy, df = 4)
bs(attnoy[,1])
splines::bs(attnoy[,1])
devtools::load_all()
x <- grpmat(attnoy, df = 4)
fit <- grpreg(x, attitude$rating, penalty="grLasso", returnX = TRUE)
devtools::load_all()
fit <- grpreg(x, attitude$rating, penalty="grLasso", returnX = TRUE)
plot.sp.grpreg(fit, "complaints", 31)
plot.sp.grpreg(fit, "complaints", 31)
devtools::load_all()
plot.sp.grpreg(fit, "complaints", 31)
plot.sp.grpreg(fit, "complaints", 31)
devtools::load_all()
plot.sp.grpreg(fit, "complaints", 31)
emp <- cbind(x$x[1], x$x[2], x$x[3])
View(x)
emp <- cbind(x$x[,1], x$x[,2], x$x[,3])
attr(emp, "intercept") <- 3
attr(emp, "intercept") <- 0
emp <- cbind(x$x[,1], x$x[,2], x$x[,3])
attr(emp, "intercept") <- 0
emp <- cbind(x$x[,1], x$x[,2], x$x[,3])
attr(emp, "intercept") <- FALSE
attributes(x$x)
